---
# Production Deployment Workflow
#
# Requirements:
# - GITOPS_PAT secret must have 'Contents: Write' permission
# - GITOPS_PAT must have permission to bypass branch protection rules
# - Alternatively, configure branch protection to allow github-actions[bot] to bypass
#
# SECURITY RECOMMENDATIONS for GITOPS_PAT:
# 1. Use Fine-Grained Personal Access Token (not Classic PAT)
# 2. Grant MINIMAL permissions:
#    - Repository access: Only 'nikolay-e/gitops' (not all repositories)
#    - Permissions: Contents (Read and Write) ONLY
# 3. Set expiration: 1 year maximum (rotate annually)
# 4. Enable MFA on the GitHub account owning the token
# 5. Review token usage logs quarterly via GitHub Audit Log
# 6. CRITICAL: This token can bypass branch protection - treat as production credential
# 7. Alternative (more secure): Use GitHub App with repository-scoped credentials
#    - Create GitHub App with 'Contents: Write' permission
#    - Install app only on gitops repository
#    - Use App authentication instead of PAT (app-token action)
#
# Migration to GitHub App (recommended):
# Replace GITOPS_PAT with:
#   - uses: actions/create-github-app-token@v2
#     with:
#       app-id: ${{ secrets.GITOPS_APP_ID }}
#       private-key: ${{ secrets.GITOPS_APP_PRIVATE_KEY }}
#       repositories: gitops
#
name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type "deploy" to confirm production deployment'
        required: true
        type: string

env:
  REGISTRY: ghcr.io/${{ github.repository }}
  GITOPS_REPO: nikolay-e/gitops

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: ${{ github.event.inputs.confirm == 'deploy' }}
    permissions:
      contents: write
      packages: write
      deployments: write

    steps:
      - name: Checkout main branch
        uses: actions/checkout@v5
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.GITOPS_PAT }}

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '22'
          cache: 'npm'

      - name: Get current version and increment
        id: version
        run: |
          # Get current version from package.json
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "Current version: ${CURRENT_VERSION}"

          # Split version into major.minor.patch
          IFS='.' read -r -a VERSION_PARTS <<< "${CURRENT_VERSION}"
          MAJOR="${VERSION_PARTS[0]}"
          MINOR="${VERSION_PARTS[1]}"
          PATCH="${VERSION_PARTS[2]}"

          # Increment patch version by 1
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"

          echo "New version: ${NEW_VERSION}"
          {
            echo "current=${CURRENT_VERSION}"
            echo "new=${NEW_VERSION}"
            echo "tag=v${NEW_VERSION}"
          } >> "$GITHUB_OUTPUT"

      - name: Update version in package.json
        run: |
          # Update version in root package.json
          npm version ${{ steps.version.outputs.new }} --no-git-tag-version

          # Update version in all workspace packages
          for package_json in packages/*/package.json; do
            if [ -f "$package_json" ]; then
              echo "Updating version in $package_json"
              cd "$(dirname "$package_json")"
              npm version ${{ steps.version.outputs.new }} --no-git-tag-version
              cd - > /dev/null
            fi
          done

      - name: Commit version update
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add package.json packages/*/package.json
          git commit -m "chore: bump version to ${{ steps.version.outputs.new }}"

          # Push to main
          git push origin main

      - name: Create and push Git tag
        run: |
          git tag ${{ steps.version.outputs.tag }}
          git push origin ${{ steps.version.outputs.tag }}

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push backend image
        uses: docker/build-push-action@v6
        with:
          context: .
          target: backend
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ env.REGISTRY }}/lingua-quiz-backend:${{ steps.version.outputs.tag }}
            ${{ env.REGISTRY }}/lingua-quiz-backend:latest
            ${{ env.REGISTRY }}/lingua-quiz-backend:${{ github.sha }}
          build-args: |
            APP_VERSION=${{ steps.version.outputs.new }}
            APP_ENVIRONMENT=production
          labels: |
            org.opencontainers.image.source=${{ github.event.repository.html_url }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ steps.version.outputs.new }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend image
        uses: docker/build-push-action@v6
        with:
          context: .
          target: frontend
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ env.REGISTRY }}/lingua-quiz-frontend:${{ steps.version.outputs.tag }}
            ${{ env.REGISTRY }}/lingua-quiz-frontend:latest
            ${{ env.REGISTRY }}/lingua-quiz-frontend:${{ github.sha }}
          build-args: |
            APP_VERSION=${{ steps.version.outputs.new }}
            APP_ENVIRONMENT=production
          labels: |
            org.opencontainers.image.source=${{ github.event.repository.html_url }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ steps.version.outputs.new }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Checkout GitOps repository
        uses: actions/checkout@v5
        with:
          repository: ${{ env.GITOPS_REPO }}
          token: ${{ secrets.GITOPS_PAT }}
          ref: main
          path: gitops

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Update production image tags in GitOps
        working-directory: gitops
        run: |
          TAG="${{ steps.version.outputs.tag }}"

          echo "Updating production to ${TAG}..."

          # Update production Application
          PROD_FILE="argocd/applications/production.yaml"

          # Use sed to replace the image tags - more reliable for inline YAML strings
          sed -i "s|tag: [a-zA-Z0-9._-]*$|tag: ${TAG}|g" "${PROD_FILE}"

          echo "Updated production to ${TAG}"
          git diff "${PROD_FILE}"

      - name: Commit and push GitOps changes
        working-directory: gitops
        run: |
          TAG="${{ steps.version.outputs.tag }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add argocd/applications/production.yaml

          git commit -m "prod: deploy ${TAG} to production" \
            -m "Version: ${{ steps.version.outputs.new }}" \
            -m "Commit: ${{ github.sha }}" \
            -m "Automated production deployment via GitHub Actions"

          git push origin main

          echo "Pushed to GitOps repository"

      - name: Cleanup old production deployments
        uses: ./.github/actions/cleanup-deployment
        with:
          environment: 'production'
          delete-environment: 'false'

      - name: Create production deployment
        id: deployment
        uses: ./.github/actions/create-deployment
        with:
          environment: 'production'
          ref: ${{ steps.version.outputs.tag }}
          is-production: 'true'
          is-transient: 'false'
          description: 'Production deployment v${{ steps.version.outputs.new }}'
          payload: |
            {
              "release_version": "${{ steps.version.outputs.new }}",
              "git_tag": "${{ steps.version.outputs.tag }}",
              "commit_sha": "${{ github.sha }}",
              "deployed_by": "github-actions",
              "deployment_type": "manual"
            }
          environment-url: 'https://lingua-quiz.nikolay-eremeev.com'
          initial-status: 'in_progress'
          status-description: 'Deploying v${{ steps.version.outputs.new }} to production via ArgoCD'

      - name: Mark deployment as successful
        uses: ./.github/actions/update-deployment-status
        with:
          environment: 'production'
          deployment-id: ${{ steps.deployment.outputs.deployment-id }}
          status: 'success'
          description: 'âœ… Deployed v${{ steps.version.outputs.new }} to production'
          environment-url: 'https://lingua-quiz.nikolay-eremeev.com'

      - name: Create GitHub Release
        uses: actions/github-script@v8
        with:
          script: |
            let previousTag;
            try {
              const latestRelease = await github.rest.repos.getLatestRelease({
                owner: context.repo.owner,
                repo: context.repo.repo
              });
              previousTag = latestRelease.data.tag_name;
            } catch (error) {
              console.log('No previous release found');
              previousTag = null;
            }

            let releaseNotes = `**Version:** ${{ steps.version.outputs.new }}\n`;
            releaseNotes += `**Commit:** \`${{ github.sha }}\`\n\n`;

            releaseNotes += `**Images:**\n`;
            releaseNotes += `- \`ghcr.io/${{ github.repository }}/lingua-quiz-backend:${{ steps.version.outputs.tag }}\`\n`;
            releaseNotes += `- \`ghcr.io/${{ github.repository }}/lingua-quiz-frontend:${{ steps.version.outputs.tag }}\`\n\n`;

            releaseNotes += `**Links:**\n`;
            releaseNotes += `- Production: https://lingua-quiz.nikolay-eremeev.com\n`;
            releaseNotes += `- Health Check: https://lingua-quiz.nikolay-eremeev.com/api/health\n`;

            if (previousTag) {
              const compareUrl = `https://github.com/${{ github.repository }}/compare/${previousTag}...${{ steps.version.outputs.tag }}`;
              releaseNotes += `\n[Full Changelog](${compareUrl})\n`;
            }

            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: '${{ steps.version.outputs.tag }}',
              name: '${{ steps.version.outputs.tag }}',
              body: releaseNotes,
              draft: false,
              prerelease: false,
              generate_release_notes: false
            });

            console.log(`Created release: ${release.data.html_url}`);

      - name: Trigger ArgoCD sync
        run: |
          echo "ArgoCD will auto-detect the change and sync production"
          echo "Production deployment initiated"

      - name: Summary
        run: |
          {
            echo "## Production Deployed Successfully"
            echo ""
            echo "### Version Information"
            echo "- **Previous Version:** \`${{ steps.version.outputs.current }}\`"
            echo "- **New Version:** \`${{ steps.version.outputs.new }}\`"
            echo "- **Git Tag:** \`${{ steps.version.outputs.tag }}\`"
            echo ""
            echo "### Docker Images"
            echo "- Backend: \`${{ env.REGISTRY }}/lingua-quiz-backend:${{ steps.version.outputs.tag }}\`"
            echo "- Frontend: \`${{ env.REGISTRY }}/lingua-quiz-frontend:${{ steps.version.outputs.tag }}\`"
            echo ""
            echo "### Links"
            echo "- **Production URL:** https://lingua-quiz.nikolay-eremeev.com"
            echo "- **Health Check:** https://lingua-quiz.nikolay-eremeev.com/api/health"
            echo "- **GitHub Release:** https://github.com/${{ github.repository }}/releases/tag/${{ steps.version.outputs.tag }}"
            echo ""
            echo "### Deployment Steps Completed"
            echo "1. Incremented version to ${{ steps.version.outputs.new }}"
            echo "2. Committed and pushed version update to main"
            echo "3. Created and pushed Git tag ${{ steps.version.outputs.tag }}"
            echo "4. Built and pushed Docker images with version tag"
            echo "5. Updated GitOps repository with new version"
            echo "6. Recreated GitHub deployment"
            echo "7. Created GitHub release"
            echo "8. ArgoCD sync triggered"
            echo ""
            echo "**Deployment complete**"
          } >> "$GITHUB_STEP_SUMMARY"
