name: Execute SQL Query (Admin Only)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - production
          - staging
        default: staging
      sql_query:
        description: 'SQL query to execute (be careful!)'
        required: true
        type: string
      dry_run:
        description: 'Dry run (show query without executing)'
        required: false
        type: boolean
        default: true
      confirm_destructive:
        description: 'Type "CONFIRM" to allow UPDATE/DELETE/DROP queries'
        required: false
        type: string
        default: ''

permissions:
  contents: read

jobs:
  check-permissions:
    runs-on: ubuntu-latest
    outputs:
      is_admin: ${{ steps.check.outputs.is_admin }}
    steps:
      - name: Check if user is admin
        id: check
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get the user who triggered the workflow
          ACTOR="${{ github.actor }}"
          REPO="${{ github.repository }}"
          
          echo "Checking permissions for user: $ACTOR"
          
          # Check if user has admin permissions on the repository
          PERMISSION_LEVEL=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/$REPO/collaborators/$ACTOR/permission" \
            | jq -r '.permission')
          
          echo "User permission level: $PERMISSION_LEVEL"
          
          # Check if user is repository admin
          if [[ "$PERMISSION_LEVEL" == "admin" ]]; then
            echo "‚úÖ User $ACTOR has admin permissions"
            echo "is_admin=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå User $ACTOR does not have admin permissions"
            echo "is_admin=false" >> $GITHUB_OUTPUT
            
            # Also check if user is in the admin team (optional)
            # Replace 'your-org' and 'admin-team' with your actual org and team names
            # TEAM_MEMBER=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            #   "https://api.github.com/orgs/your-org/teams/admin-team/memberships/$ACTOR" \
            #   | jq -r '.state')
            # 
            # if [[ "$TEAM_MEMBER" == "active" ]]; then
            #   echo "‚úÖ User $ACTOR is in admin team"
            #   echo "is_admin=true" >> $GITHUB_OUTPUT
            # fi
          fi

      - name: Fail if not admin
        if: steps.check.outputs.is_admin != 'true'
        run: |
          echo "‚ùå ERROR: Only repository admins can execute SQL queries"
          echo "User ${{ github.actor }} does not have sufficient permissions"
          exit 1

  execute-sql:
    needs: check-permissions
    if: needs.check-permissions.outputs.is_admin == 'true'
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    steps:
      - name: Log execution start
        run: |
          echo "üìù SQL Query Execution Audit Log"
          echo "================================"
          echo "Executed by: ${{ github.actor }}"
          echo "Environment: ${{ github.event.inputs.environment }}"
          echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "Workflow Run ID: ${{ github.run_id }}"
          echo "================================"

      - name: Validate inputs
        run: |
          # Check for potentially destructive queries
          SQL_UPPER=$(echo "${{ github.event.inputs.sql_query }}" | tr '[:lower:]' '[:upper:]')
          
          if [[ "$SQL_UPPER" =~ (DELETE|DROP|TRUNCATE|UPDATE) ]]; then
            echo "‚ö†Ô∏è WARNING: Potentially destructive query detected!"
            if [[ "${{ github.event.inputs.confirm_destructive }}" != "CONFIRM" ]]; then
              echo "‚ùå ERROR: Destructive queries require typing 'CONFIRM' in the confirmation field"
              exit 1
            fi
            echo "‚úÖ Destructive query confirmed by ${{ github.actor }}"
          fi
          
          # Enhanced SQL injection prevention
          SUSPICIOUS_PATTERNS=(
            ".*;.*--"
            "UNION.*SELECT"
            "OR.*1.*=.*1"
            "DROP.*DATABASE"
            "DROP.*SCHEMA"
            "GRANT.*TO"
            "REVOKE.*FROM"
            "CREATE.*USER"
            "ALTER.*USER"
            "';.*--"
            "/*.*\*/"
            "xp_cmdshell"
            "sp_executesql"
          )
          
          for pattern in "${SUSPICIOUS_PATTERNS[@]}"; do
            if [[ "$SQL_UPPER" =~ $pattern ]]; then
              echo "‚ùå ERROR: Suspicious SQL pattern detected: $pattern"
              exit 1
            fi
          done
          
          # Limit query length to prevent abuse
          QUERY_LENGTH=${#{{ github.event.inputs.sql_query }}}
          if [ $QUERY_LENGTH -gt 5000 ]; then
            echo "‚ùå ERROR: Query too long (max 5000 characters, got $QUERY_LENGTH)"
            exit 1
          fi
          
          echo "‚úÖ Query validation passed"

      - name: Setup kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          kubectl version --client

      - name: Configure kubeconfig
        env:
          KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG }}
        run: |
          mkdir -p $HOME/.kube
          echo "$KUBE_CONFIG_DATA" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          echo "Kubeconfig configured"

      - name: Set environment variables
        run: |
          if [[ "${{ github.event.inputs.environment }}" == "production" ]]; then
            echo "NAMESPACE=lingua-quiz-production" >> $GITHUB_ENV
            echo "RELEASE_NAME=lingua-quiz" >> $GITHUB_ENV
          else
            echo "NAMESPACE=lingua-quiz-staging" >> $GITHUB_ENV
            echo "RELEASE_NAME=lingua-quiz" >> $GITHUB_ENV
          fi
          echo "DB_NAME=${{ secrets.POSTGRES_DB }}" >> $GITHUB_ENV
          echo "DB_USER=${{ secrets.POSTGRES_USER }}" >> $GITHUB_ENV

      - name: Find PostgreSQL pod
        run: |
          echo "Looking for PostgreSQL pod in namespace: ${{ env.NAMESPACE }}"
          
          # Try to find the postgres pod
          POSTGRES_POD=$(kubectl get pods -n ${{ env.NAMESPACE }} -l "app.kubernetes.io/name=postgresql" -o jsonpath="{.items[0].metadata.name}" 2>/dev/null)
          
          if [ -z "$POSTGRES_POD" ]; then
            # Try alternative label
            POSTGRES_POD=$(kubectl get pods -n ${{ env.NAMESPACE }} -l "app=postgres" -o jsonpath="{.items[0].metadata.name}" 2>/dev/null)
          fi
          
          if [ -z "$POSTGRES_POD" ]; then
            # Try to find by release name
            POSTGRES_POD=$(kubectl get pods -n ${{ env.NAMESPACE }} -l "app.kubernetes.io/instance=${{ env.RELEASE_NAME }}" -o jsonpath="{.items[*].metadata.name}" | tr ' ' '\n' | grep -i postgres | head -1)
          fi
          
          if [ -z "$POSTGRES_POD" ]; then
            echo "‚ùå ERROR: Could not find PostgreSQL pod"
            echo "Available pods in namespace:"
            kubectl get pods -n ${{ env.NAMESPACE }}
            exit 1
          fi
          
          echo "POSTGRES_POD=$POSTGRES_POD" >> $GITHUB_ENV
          echo "‚úÖ Found PostgreSQL pod: $POSTGRES_POD"

      - name: Show query (Dry Run)
        if: github.event.inputs.dry_run == 'true'
        run: |
          echo "üîç DRY RUN MODE - Query will NOT be executed"
          echo "Environment: ${{ github.event.inputs.environment }}"
          echo "Namespace: ${{ env.NAMESPACE }}"
          echo "Database: ${{ env.DB_NAME }}"
          echo "User: ${{ env.DB_USER }}"
          echo "Executing user: ${{ github.actor }}"
          echo ""
          echo "SQL Query to execute:"
          echo "----------------------------------------"
          echo "${{ github.event.inputs.sql_query }}"
          echo "----------------------------------------"

      - name: Create backup before execution
        if: github.event.inputs.dry_run == 'false' && contains(github.event.inputs.sql_query, 'UPDATE') || contains(github.event.inputs.sql_query, 'DELETE') || contains(github.event.inputs.sql_query, 'DROP')
        run: |
          echo "üì¶ Creating backup before destructive operation..."
          
          # Trigger a backup job before executing destructive queries
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          BACKUP_NAME="pre_sql_execution_${TIMESTAMP}_by_${{ github.actor }}"
          
          kubectl exec -n "${{ env.NAMESPACE }}" "${{ env.POSTGRES_POD }}" -- \
            env PGPASSWORD="${{ secrets.POSTGRES_PASSWORD }}" \
            pg_dump -U "${{ env.DB_USER }}" -d "${{ env.DB_NAME }}" -f "/tmp/${BACKUP_NAME}.sql"
          
          echo "‚úÖ Backup created: ${BACKUP_NAME}.sql"

      - name: Execute SQL query
        if: github.event.inputs.dry_run == 'false'
        env:
          PGPASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        run: |
          echo "üöÄ Executing SQL query in ${{ github.event.inputs.environment }} environment"
          echo "Namespace: ${{ env.NAMESPACE }}"
          echo "Pod: ${{ env.POSTGRES_POD }}"
          echo "Executed by: ${{ github.actor }}"
          echo ""
          
          # Log the query being executed (for audit trail)
          echo "Query hash: $(echo -n "${{ github.event.inputs.sql_query }}" | sha256sum | cut -d' ' -f1)"
          
          # Create a temporary file with the SQL query
          QUERY_FILE=$(mktemp)
          echo "${{ github.event.inputs.sql_query }}" > "$QUERY_FILE"
          
          # Copy the query file to the pod
          kubectl cp "$QUERY_FILE" "${{ env.NAMESPACE }}/${{ env.POSTGRES_POD }}:/tmp/query.sql"
          
          # Execute the query with timing
          echo "Executing query..."
          echo "========================================="
          START_TIME=$(date +%s)
          
          kubectl exec -n "${{ env.NAMESPACE }}" "${{ env.POSTGRES_POD }}" -- \
            env PGPASSWORD="${{ secrets.POSTGRES_PASSWORD }}" \
            psql -U "${{ env.DB_USER }}" -d "${{ env.DB_NAME }}" -f /tmp/query.sql
          
          RESULT=$?
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          
          echo "========================================="
          echo "Execution time: ${DURATION} seconds"
          
          # Cleanup
          kubectl exec -n "${{ env.NAMESPACE }}" "${{ env.POSTGRES_POD }}" -- rm -f /tmp/query.sql
          rm -f "$QUERY_FILE"
          
          if [ $RESULT -eq 0 ]; then
            echo "‚úÖ Query executed successfully by ${{ github.actor }}"
          else
            echo "‚ùå Query execution failed"
            exit 1
          fi

      - name: Show example usage
        if: github.event.inputs.dry_run == 'true'
        run: |
          echo ""
          echo "üìù Example queries for your use case:"
          echo ""
          echo "-- Reset specific translations to LEVEL_0 for all users:"
          echo "UPDATE user_translation_progress"
          echo "SET status = 'LEVEL_0', updated_at = CURRENT_TIMESTAMP"
          echo "WHERE word_pair_id IN (3000000, 3000001, 3000002, 3000003, 3000004);"
          echo ""
          echo "-- Create LEVEL_0 records for all users (if not exists):"
          echo "INSERT INTO user_translation_progress (user_id, word_pair_id, status)"
          echo "SELECT u.id, t.translation_id, 'LEVEL_0'"
          echo "FROM \"user\" u"
          echo "CROSS JOIN (VALUES (3000000), (3000001), (3000002), (3000003), (3000004)) AS t(translation_id)"
          echo "ON CONFLICT (user_id, word_pair_id)"
          echo "DO UPDATE SET status = 'LEVEL_0', updated_at = CURRENT_TIMESTAMP;"
          echo ""
          echo "-- Check current status of specific translations:"
          echo "SELECT word_pair_id, status, COUNT(*) as user_count"
          echo "FROM user_translation_progress"
          echo "WHERE word_pair_id IN (3000000, 3000001, 3000002, 3000003, 3000004)"
          echo "GROUP BY word_pair_id, status"
          echo "ORDER BY word_pair_id, status;"

      - name: Send notification
        if: github.event.inputs.dry_run == 'false' && always()
        continue-on-error: true
        run: |
          # You can add Slack/email notification here
          echo "üìß Notification: SQL query executed by ${{ github.actor }} in ${{ github.event.inputs.environment }}"