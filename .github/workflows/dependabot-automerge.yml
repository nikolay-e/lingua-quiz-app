name: Dependabot Auto-merge

on:
  # Trigger after CI workflow completes successfully on any PR
  workflow_run:
    workflows: ["CI"]
    types: [completed]

permissions:
  contents: write
  pull-requests: write

jobs:
  automerge:
    name: Auto-merge Minor/Patch Updates
    runs-on: ubuntu-latest
    # Only run on PRs from Dependabot when CI succeeds
    if: >
      github.event.workflow_run.event == 'pull_request' &&
      github.event.workflow_run.conclusion == 'success' &&
      github.event.workflow_run.actor.login == 'dependabot[bot]'

    steps:
      - name: Get PR details
        id: pr
        uses: actions/github-script@v8
        with:
          script: |
            // Get PR from workflow_run event
            const pr = context.payload.workflow_run.pull_requests[0];
            if (!pr) {
              console.log('No PR associated with this workflow run');
              return;
            }

            // Fetch full PR details to get node_id
            const { data: pullRequest } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });

            core.setOutput('number', pullRequest.number);
            core.setOutput('node_id', pullRequest.node_id);
            core.setOutput('title', pullRequest.title);
            core.setOutput('labels', JSON.stringify(pullRequest.labels.map(l => l.name)));

      - name: Check PR labels
        id: check
        if: steps.pr.outputs.number
        uses: actions/github-script@v8
        with:
          script: |
            const title = `${{ steps.pr.outputs.title }}`.toLowerCase();
            const labels = JSON.parse(`${{ steps.pr.outputs.labels }}`);

            // Parse semver from title: "Bump foo from X.Y.Z to A.B.C"
            const match = title.match(/bump .* from (\d+)\.(\d+)\.(\d+) to (\d+)\.(\d+)\.(\d+)/i);

            if (!match) {
              console.log(`✗ Skip auto-merge: Could not parse version from title: ${title}`);
              core.setOutput('automerge', false);
              return;
            }

            const fromMajor = parseInt(match[1]);
            const toMajor = parseInt(match[4]);
            const isMajorBump = toMajor > fromMajor;

            // Block major bumps AND sensitive paths (infra, helm, clusters)
            const hasDependenciesLabel = labels.includes('dependencies');
            const shouldAutomerge = !isMajorBump && hasDependenciesLabel;

            core.setOutput('automerge', shouldAutomerge);

            if (shouldAutomerge) {
              console.log(`✓ Will auto-merge: ${title} (${fromMajor}.x.x → ${toMajor}.x.x)`);
            } else if (isMajorBump) {
              console.log(`✗ Skip auto-merge: Major version bump detected (${fromMajor} → ${toMajor})`);
            } else if (!hasDependenciesLabel) {
              console.log(`✗ Skip auto-merge: Missing 'dependencies' label`);
            } else {
              console.log(`✗ Skip auto-merge: ${title}`);
            }

      - name: Enable auto-merge
        if: steps.check.outputs.automerge == 'true'
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          PR_NODE_ID: ${{ steps.pr.outputs.node_id }}
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = process.env.PR_NUMBER;
            const prNodeId = process.env.PR_NODE_ID;

            // Use GitHub's GraphQL API to enable auto-merge
            // The REST API doesn't have this endpoint - must use GraphQL
            // This runs AFTER CI passes, so the PR should be in a stable state
            try {
              await github.graphql(`
                mutation($pullRequestId: ID!, $mergeMethod: PullRequestMergeMethod!) {
                  enablePullRequestAutoMerge(input: {
                    pullRequestId: $pullRequestId,
                    mergeMethod: $mergeMethod
                  }) {
                    pullRequest {
                      autoMergeRequest {
                        enabledAt
                      }
                    }
                  }
                }
              `, {
                pullRequestId: prNodeId,
                mergeMethod: 'SQUASH'
              });

              console.log(`✓ Auto-merge enabled for PR #${prNumber}`);
              console.log('  PR will merge automatically once all remaining checks pass');
            } catch (error) {
              // Handle common errors gracefully
              if (error.message?.includes('already has')) {
                console.log(`ℹ️  Auto-merge already enabled for PR #${prNumber}`);
              } else if (error.message?.includes('not allowed')) {
                console.log(`⚠️  Auto-merge not available for this repository`);
              } else if (error.message?.includes('unstable status')) {
                console.log(`⚠️  PR #${prNumber} still has pending/failing checks, cannot enable auto-merge yet`);
              } else if (error.message?.includes('clean status')) {
                console.log(`✅ PR #${prNumber} is already in clean status (all checks passed)`);
                console.log(`   The PR can be merged manually or will auto-merge if more checks are added`);
              } else {
                console.error('Error enabling auto-merge:', error.message);
                throw error;
              }
            }
